<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>14.构造函数</title>
</head>
<body>

<script>
  // function createJsPerson (name,age) {
  //   var obj = {};
  //   obj.name = name;
  //   obj.age = age;
  //   obj.writeJs = function () {
  //     console.log("My Name is "+this.name+" ,i can write js 啦~~");
  //   };
  //   return obj;
  // }
  //
  // var p1 = createJsPerson('张三',18);
  // p1.writeJs();


  // 构造函数的目的就是为了创建一个自定义类，并且创建这个类的实例


  function CreateJsPerson (name,age) {
    // 浏览器默认创建的对象就是我们的实例 p1 -> this
    this.name = name;
    this.age = age;
    this.writeJs = function () {
      console.log("My Name is "+this.name+" ,i can write js 啦~~");
    };
    // 浏览器再把创建的实例默认的进行返回
  }

  var p1 = new CreateJsPerson('张三', 18);
  p1.writeJs();  // writeJs -> this p1
  var res = CreateJsPerson("王尔曼",7);// 这样写不是构造函数执行是普通函数执行 由于没有写return所以res=undefined 并且CreateJsPerson这个方法中的this是window
  console.log(res);// undefined


  var p2 = new CreateJsPerson('李四', 48);
  p2.writeJs();


  // 构造函数模式和  工厂模式的区别？
  // 1、执行的时候
  // 普通函数执行->createJsPerson()
  // 构造函数模式-> new CreateJsPerson()  通过new执行后，我们的createJsPerson就是一个类了
  // 而函数执行的返回值(p1)就是CreateJsPerson这个类的一个实例
  //


  // 创建一个数组：
  // var ary = [];    // 字面量方式
  // var ary = new Array();  // 实例创建的方式->构造函数模式执行的方式
  // 不管那种的方式，ary都是Array这个类的一个实例

  // 1、JS中所有的类都是函数数据类型的，它通过new执行变成了一个类，但是他本身也是一个普通的函数；JS中所有的实例都是对象数据类型的
  // 2、在构造函数中，类中(函数体中)出现的this.xxx = xxx 中的this，是当前类的一个实例
  // 3、p1和p2都是CreateJsPerson这个类的实例，所以都拥有writeJs这个方法，但是不同实例之间的方法是不一样
  // 在类中给实例增加的属性(this.xxx = xxx)属于当前实例的私有的属性，实例和实例之间是单独的个体，所以的私有属性不是同一个
  // console.log(p1.writeJs === p2.writeJs); // -> false

  // 2、在函数代码执行的时候
  // 相同：都是形成一个私有作用域，然后形参赋值->预解释->代码从上到下执行（类和普通函数一样，它也有普通函数的一面）
  // 不同：在代码执行之前，不用自己手动创建对象了，浏览器会默认的创建一个对象数据类型的值（这个对象其实就是我们当前类的一个实例）
  // 接下来代码从上到下执行，以当前实例为执行的主体（this代表的就是当前的实例），然后分别的把属性名和属性值复制给当前的实例
  // 最后浏览器会默认的把创建的实例返回

</script>
</body>
</html>
