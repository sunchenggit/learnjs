<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>7.内存的释放和销毁</title>
</head>
<body>

  <script>

    // 堆内存
    //  对象数据类型或则函数数据类型在定义的时候首先都会开辟一个堆内存，堆内存有一个引用的地址，如果外面有变量等知道了这个地址，我们就说这个内存被占用了，就不能销毁了

    // var obj1 = { name:"张三" };

    // var obj2 = obj1;
    // 我们想要让堆内存释放/销毁，只需要把所有引用他的变量值复制为null即可，如果当亲的堆内存没有任何东西被占用了，那么浏览器在空闲的时候把它销毁
    // obj1 = null;
    // obj2 = null;

    // console.log(obj2);



    // 栈内存
    // 1）、全局作用域
    // 只有当页面关闭的时候，全局作用域才会销毁
    //
    // 2）、私有作用域(只有函数执行会产生私有作用域)
    // 一般情况下，函数执行会形成一个的私有作用域，当私有作用域中的代码执行完成后我们当前作用域都会主动的释放和销毁
    // 但是还是会出现特殊的情况的：
    // 当前私有作用域的部分内存被作用域以外的东西占用了，那么当前的作用域就不能销毁了
    // a)函数执行返回了一个引用数据类型的值，并且在函数之的外面被一个其他的东西给接收了，这种情况下一般形成的私有作用域都不会被销毁
    // b)在一个私有的作用域中给DOM事件绑定方法，一般情况下我们的私有作用域都不销毁
    // var vDiv = document.getElementById('div1');
    // ~function(){
    //   vDiv.onclick = function(){}
    // }();//当前这个私有的作用域也不会被销毁
    // c)下述情况下不立即销毁-> fn返回的函数没有呗其他的东西占用，但是还需要执行一次呢，所以占时不销毁，当返回的执行完成后，浏览器会在空闲的时候把它销毁了->不立即销毁

    function fn(){
      var num = 100;
      return function (){
        num++;
        console.log(num)
      }
    }

    var f = fn();

    // 这些都不会产生作用域，这些大括号叫代码块
    for(){}
    if(){}
    switch(){}

  </script>
</body>
</html>
