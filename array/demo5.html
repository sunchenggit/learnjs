<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

  <script>
      var ary = [1,2,12,4,5,6,7,1,34,5,6,7,1,2,34,5,7,7,8,5,23,66,3,2,6,2];

      //var obj = {};

      // for (var i = 0; i < ary.length; i++ ) {
      //   var cur = ary[i];
      //   if(typeof obj[cur] !== 'undefined'){
      //     //=>对象中已经存在改属性：证明当前项是数组中的重复项
      //     ary.splice(i,1);
      //     i--;
      //     continue;
      //   }
      //   obj[cur] = cur; //=> obj[1] = 1;   {1:1} 存储
      // }

      // for (var i = 0; i < ary.length; i++ ) {
      //   var cur = ary[i];
      //   if(typeof obj[cur] !== 'undefined'){
      //     // ary.splice(i,1); //=>使用splice会导致后面的索引向前进一位，如果后面有很多项，消耗性能很大
      //     // i--;
      //
      //     //=>思路：我们把最后一项拿过来替换当前要删除的这一项，然后再把最后一项删除
      //     ary[i] = ary[ary.length - 1];
      //     ary.length--;
      //     i--;//=> 虽然索引是对的，但是当前项的值被改变了，所以还是要i--重新对当前项在进行一次判断
      //     continue;
      //   }
      //   obj[cur] = cur;
      // }


      Array.prototype.myUnique = function myUnique() {
        var obj = {};
        for(var i = 0; i < this.length; i++ ){
          var item = this[i];
          if(typeof obj[item] !== 'undefined'){
            this[i] = this[this.length - 1];
            this.length--;
            i--;
            continue;
          }
          obj[item] = item;
        }
        obj = null;
        return this;
      }
      ary.myUnique().sort(function (a,b) {
        return a - b;
      });
      console.log(ary);
  </script>
</body>
</html>
