<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>冒泡排序</title>
</head>
<body>

<script>
  // var ary = [12,13,23,14,16,25,11];
  // ary.sort(function(a,b){
  //   return a-b;
  // })


  //=> 冒泡排序
  //原理：让数组中当前项和后一项进行比较，如果当前项大于后一项，我们让两者交换位置(小->大)
  /**
   * 第一轮比较
   * 12 13 [12,13,23,14,16,25,11];
   * 13 23 [12,13,23,14,16,25,11];
   * 23 14 [12,13,14,23,16,25,11];
   * 23 16 [12,13,14,16,23,25,11];
   * 23 25 [12,13,14,16,23,25,11];
   * 25 11 [12,13,14,16,23,11,25];
   * 第二轮比较
   * 12 13 [12,13,14,16,23,11,25];
   * 13 14 [12,13,14,16,23,11,25];
   * 11 16 [12,13,14,16,23,11,25];
   * 16 23 [12,13,14,16,23,11,25];
   * 23 11 [12,13,14,16,11,23,25];
   * ...
   *  每一轮从前到后两两比较，虽然不一定实现最后的排序效果，但是可以把当前最大的放在末尾。
   *  具体比较的轮数：ary.length-1; 数组有多长，我们只需要把总长度-1个数分别放在末尾，即可实现最后的排序
   *  第一轮比较6次：一个7个不需要和自己比较
   *  第二轮比较5次：一共7个 不用和自己比，也不用和第一轮放在末尾的那个最大值比较
   *  第三轮比较4次：一共7个 不用和自己比，也不用和第一轮第二轮放在末尾的最大值比较
   *  ...
   *  每一轮比较的次数
   *  ary.length-1(不用和自己比较)-当前已经执行过的轮数（执行一轮向末尾放一个最大值，这个值不需要在比较）
   *  a = 12;
   *  b = 13;
   *  a和b交换值
   *  c = a;  // 将a的值存给c
   *  a = b;  // a变成b
   *  b = c;  // b变成c，c里存的是a的值，所以b的值就变成了之前a的值
   *
   *  a = a+b;  a=25;
   *  b = a-b;  b=25-13 b=12;
   *  a = a-b;  a=25-12 a=13;
   */
  // var ary = [12,13,23,14,16,25,11];
  //

  /**
   * bubble：冒泡排序
   * @param  {Array} ary [需要实现排序的数组]
   * @return {array}     [排序后的数组(升序)]
   */
  function bubble (ary) {
    // 外层循环控制的是比较的轮数
    for(var i = 0; i < ary.length - 1; i++){
      //=> 里层循环控制的是每一轮比较的次数
      for(var j =0; j < ary.length - 1 - i;j++){
        // ary[j]:当前本次拿出来的这一项
        // ary[j+1]:当前项的最后一项
        if(ary[j] > ary[j+1]){
          //=>当前这一项比后  一项还要大，我们让两者交换位置
          var temp = ary[j];
          ary[j] = ary[j+1];
          ary[j+1] = temp;
        }
      }
    }
    return ary;
  }
  var ary = [12,13,23,14,16,25,11];
  bubble(ary);

</script>
</body>
</html>
